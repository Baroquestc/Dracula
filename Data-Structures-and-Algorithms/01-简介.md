# 01-简介

## 1 特征

1. **输入**: 算法具有0个或多个输入

2. **输出**: 算法至少有1个或多个输出

3. **有穷性**: 算法在有限的步骤之后会自动结束而不会无限循环，并且每一个步骤可以在可接受的时间内完成

4. **确定性**：算法中的每一步都有确定的含义，不会出现二义性

5. **可行性**：算法的每一步都是可行的，也就是说每一步都能够执行有限的次数完成

## 2 效率衡量 

1. 执行时间（不一定客观准确）

## 3 常见时间复杂度

| 执行次数函数举例 |    阶    |
| :--------------: | :------: |
|        12        |   O(1)   |
|       2n+3       |   O(n)   |
|     3n2+2n+1     |  O(n2)   |
|    5log2n+20     | O(logn)  |
|  2n+3nlog2n+19   | O(nlogn) |
|   6n3+2n2+3n+4   |  O(n3)   |
|        2n        |  O(2n)   |

时间消耗：

*O(1) < O(logn) < O(n) < O(nlogn) < O(n2) < O(n3) < O(2n) < O(n!) < O(nn)*</u

## 4 Python内置类型性能分析

### 4.1 timeit模块

```
class timeit.Timer(stmt='pass', setup='pass', timer=<timer function>)
```

- Timer: 测量小段代码执行速度的类
- stmt: 要测试的代码语句（statment）
- setup: 运行代码时需要的设置
- timer: 一个定时器函数，与平台有关

```
timeit.Timer.timeit(number=1000000)
```

Timer类中测试语句执行速度的对象方法。number参数是测试代码时的测试次数，默认为1000000次。方法返回执行代码的平均耗时，一个float类型的秒数

* **list操作测试**

  ```python
  def test1():
     l = []
     for i in range(1000):
        l = l + [i]
  def test2():
     l = []
     for i in range(1000):
        l.append(i)
  def test3():
     l = [i for i in range(1000)]
  def test4():
     l = list(range(1000))
  
  from timeit import Timer
  
  t1 = Timer("test1()", "from __main__ import test1")
  print("concat ",t1.timeit(number=1000), "seconds")
  t2 = Timer("test2()", "from __main__ import test2")
  print("append ",t2.timeit(number=1000), "seconds")
  t3 = Timer("test3()", "from __main__ import test3")
  print("comprehension ",t3.timeit(number=1000), "seconds")
  t4 = Timer("test4()", "from __main__ import test4")
  print("list range ",t4.timeit(number=1000), "seconds")
  
  # ('concat ', 1.7890608310699463, 'seconds')
  # ('append ', 0.13796091079711914, 'seconds')
  # ('comprehension ', 0.05671119689941406, 'seconds')
  # ('list range ', 0.014147043228149414, 'seconds')
  ```
  * 时间复杂度

    ![listæä½](file:///C:/Users/19107/Music/%E5%B0%8F%E7%94%B2%E9%B1%BC%20%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E7%AC%AC%E5%9B%9B%E9%83%A8/JokerJohn-black_horse_python-master/black_horse_python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/images/list%E6%93%8D%E4%BD%9C.png)

* **pop操作测试**

  ```python
  x = range(2000000)
  pop_zero = Timer("x.pop(0)","from __main__ import x")
  print("pop_zero ",pop_zero.timeit(number=1000), "seconds")
  x = range(2000000)
  pop_end = Timer("x.pop()","from __main__ import x")
  print("pop_end ",pop_end.timeit(number=1000), "seconds")
  
  # ('pop_zero ', 1.9101738929748535, 'seconds')
  # ('pop_end ', 0.00023603439331054688, 'seconds')
  # pop最后一个元素的效率远远高于pop第一个元素
  ```

- ## dict内置操作的时间复杂度

  ![dictæä½](file:///C:/Users/19107/Music/%E5%B0%8F%E7%94%B2%E9%B1%BC%20%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E7%AC%AC%E5%9B%9B%E9%83%A8/JokerJohn-black_horse_python-master/black_horse_python/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/images/dict%E6%93%8D%E4%BD%9C.png)

