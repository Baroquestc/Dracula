# 06-排序与搜索

## 1 冒泡排序

1. **代码分析**

   ```python
   def bubble_sort(alist):
       for j in range(len(alist)-1,0,-1):
           # j表示每次遍历需要比较的次数，是逐渐减小的
           for i in range(j):
               if alist[i] > alist[i+1]:
                   alist[i], alist[i+1] = alist[i+1], alist[i]
   
   li = [54,26,93,17,77,31,44,55,20]
   bubble_sort(li)
   print(li)
   ```
2. **时间复杂度**

   - 最优时间复杂度：O(n) （表示遍历一次发现没有任何可以交换的元素，排序结束。）
   - 最坏时间复杂度：O(n2)
   - 稳定性：稳定 

## 2 选择排序

1. **代码分析**

   ```python
   def selection_sort(alist):
       n = len(alist)
    # 需要进行n-1次选择操作
       for i in range(n-1):
           # 记录最小位置
           min_index = i
           # 从i+1位置到末尾选择出最小数据
           for j in range(i+1, n):
               if alist[j] < alist[min_index]:
                   min_index = j
           # 如果选择出的数据不在正确位置，进行交换
           if min_index != i:
               alist[i], alist[min_index] = alist[min_index], alist[i]
   
   alist = [54,226,93,17,77,31,44,55,20]
   selection_sort(alist)
   print(alist)
   ```
   
2. **时间复杂度**
   
   - 最优时间复杂度：O(n2)
   - 最坏时间复杂度：O(n2)
   - 稳定性：不稳定（考虑升序每次选择最大的情况） 

## 3  插入排序

1. **代码分析**

   ```python
   def insert_sort(alist):
       # 从第二个位置，即下标为1的元素开始向前插入
       for i in range(1, len(alist)):
           # 从第i个元素开始向前比较，如果小于前一个元素，交换位置
           for j in range(i, 0, -1):
               if alist[j] < alist[j-1]:
                   alist[j], alist[j-1] = alist[j-1], alist[j]
   
   alist = [54,26,93,17,77,31,44,55,20]
   insert_sort(alist)
   print(alist)
   ```

2. 时间复杂度**

   - 最优时间复杂度：O(n) （升序排列，序列已经处于升序状态）
   - 最坏时间复杂度：O(n2)
   - 稳定性：稳定

## 4  快速排序



