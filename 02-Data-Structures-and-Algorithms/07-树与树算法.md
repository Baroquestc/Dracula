# 07-树与树算法

## 1 树的存储结构

### 1.1 树的节点

![img](https://tva1.sinaimg.cn/large/006tNbRwly1ga278dzh0ij30g306sq3c.jpg)

​                  					 图1 树的示例

**结点**：使用树结构存储的每一个**数据元素**都被称为“结点”。

**父结点（双亲结点）**：A 是 B、C、D 结点的父结点

**子结点**： B、C、D 都是 A 结点的子结点

**兄弟结点**：B、C、D （都有相同的父结点）

**根结点**：每一个非空树都**有且只有一个**被称为根的结点。节点A

> 如果一个结点没有父结点，那么这个结点就是整棵树的根结点。

**叶子结点**：没有任何子结点的节点。图 1（A）： K、L、F、G、M、I、J 

### 1.2 子树和空树

树：树是由**根结点**和**若干棵子树**构成的

- 子树

> 注意：单个结点也是一棵树，只不过根结点就是它本身。图 1（A）中，结点 K、L、F 等都是树，且都是整棵树的子树。

- 空树：如果集合本身为空，那么构成的树就被称为空树。空树中没有结点。

> 补充：**在树结构中，对于具有同一个根结点的各个子树，相互之间不能有交集**。例如，图 1（A）中，除了根结点 A，其余元素又各自构成了三个子树，根结点分别为 B、C、D，这三个子树相互之间没有相同的结点。如果有，就破坏了树的结构，不能算做是一棵树。

### 1.3 结点的度和层次

- **结点的度（Degree）**：对于一个结点，拥有的子树数（结点有多少分支）。

例如，图 1（A）中，根结点 A 下分出了 3 个子树，所以，结点 A 的度为 3。

> 一棵树的度是树内各结点的度的最大值。图 1（A）表示的树中，各个结点的度的最大值为 3，所以，整棵树的度的值是 3。

- **结点的层次**：从一棵树的树根开始，树根所在层为第一层，根的孩子结点所在的层为第二层，依次类推。对于图 1（A）来说，A 结点在第一层，B、C、D 为第二层，E、F、G、H、I、J 在第三层，K、L、M 在第四层。

> 一棵树的深度（高度）是树中结点所在的最大的层次。图 1（A）树的深度为 4。

如果两个结点的父结点虽不相同，但是它们的父结点处在同一层次上，那么这两个结点互为堂兄弟。例如，图 1（A）中，结点 G 和 E、F、H、I、J 的父结点都在第二层，所以之间为堂兄弟的关系。

### 1.4 有序树和无序树

如果树中结点的子树从左到右看，谁在左边，谁在右边，是有规定的，这棵树称为有序树；反之称为无序树。

>  在有序树中，一个结点最左边的子树称为"第一个孩子"，最右边的称为"最后一个孩子"。

拿图 1（A）来说，如果是其本身是一棵有序树，则以结点 B 为根结点的子树为整棵树的第一个孩子，以结点 D 为根结点的子树为整棵树的最后一个孩子。

### 1.5 森林

**森林**：由 m（m >= 0）个**互不相交的树**组成的集合。

图 1（A）中，分别以 B、C、D 为根结点的三棵子树就可以称为森林。

树：由根结点和若干子树（森林)构成的

> Tree =（root,F）

其中，root 表示树的根结点，F 表示由 m（m >= 0）棵树组成的森林。

## 2 二叉树

### 2.1 概念

二叉树是每个节点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）

条件：

1. **本身是有序树**；
2. 树中包含的各个节点的度不能超过 2，即只能是 0、1 或者 2(并非一定为2)；

### 2.2 性质

**性质1:** 在二叉树的第i层上至多有$2^{i-1}$个结点（i>0）
**性质2:** 深度为k的二叉树至多有$2^k - 1$个结点（k>0）
*<u>**性质3:** 对于任意一棵二叉树，如果其叶结点数为$N_0$，而度数为2的结点总数为$N_2$，则$N_0=N_2+1$;</u>*

> 性质 3 证明：对于一个二叉树来说，除了度为 0 的叶子结点和度为 2 的结点，剩下的就是度为 1 的结点（设为 $n_1$），那么总结点 $n=n_0+n_1+n_2$。
> 同时，对于每一个结点来说都是由其父结点分支表示的，假设树中分枝数为 B，那么总结点数 n=B+1。而分枝数是可以通过 $n_1$ 和 $n_2$ 表示的，即 $B=n_1+2*n_2$。所以，n 用另外一种方式表示为 $n=n_1+2*n_2+1$。
> 两种方式得到的 n 值组成一个方程组，就可以得出 $n_0=n_2+1$。

*<u>**性质4:**具有n个结点的完全二叉树的深度必为 $log_2(n+1)$</u>*
*<u>**性质5:**对完全二叉树，若从上至下、从左至右编号，则编号为i 的结点，其左孩子编号必为2i，其右孩子编号必为2i＋1；其双亲的编号必为i/2（i＝1 时为根,除外）</u>*

### 2.3 满二叉树

满二叉树：**除了叶子结点**，每个结点的度都为 2

![满二叉树示意图](https://tva1.sinaimg.cn/large/006tNbRwly1ga2z2vaim3g308c05k3yc.gif)

​									图 2 满二叉树示意图

性质：

1. 满二叉树中第 i 层的节点数为 $2^{n-1}$个。
2. 深度为 k 的满二叉树必有$ 2^k-1 $个节点 ，叶子数为 $2^{k-1}$。
3. 满二叉树中不存在度为 1 的节点，每一个分支点中都两棵深度相同的子树，且叶子节点都在最底层。
4. 具有 n 个节点的满二叉树的深度为 $log_2(n+1)$。

### 2.4 完全二叉树

==如果二叉树中除去最后一层节点为满二叉树，且最后一层的结点依次从左到右分布，则此二叉树被称为完全二叉树==

![完全二叉树示意图](http://data.biancheng.net/uploads/allimg/181226/2-1Q22620003J18.gif)

​											图 3 完全二叉树示意图	

如图 3a) 所示是一棵完全二叉树，图 3b) 由于最后一层的节点没有按照从左向右分布，因此只能算作是普通的二叉树。

完全二叉树除了具有普通二叉树的性质，它自身也具有一些独特的性质，比如说，n 个结点的完全二叉树的深度为 ⌊log2n⌋+1。

> ⌊log2n⌋ 表示取小于 log2n 的最大整数。例如，⌊log24⌋ = 2，而 ⌊log25⌋ 结果也是 2。

对于任意一个完全二叉树来说，如果将含有的结点按照层次从左到右依次标号（如图 3a)），对于任意一个结点 i ，完全二叉树还有以下几个结论成立：

1. 当 i>1 时，父亲结点为结点 [i/2] 。（i=1 时，表示的是根结点，无父亲结点）
2. 如果 2*i>n（总结点的个数） ，则结点 i 肯定没有左孩子（为叶子结点）；否则其左孩子是结点 2*i 。
3. 如果 2*i+1>n ，则结点 i 肯定没有右孩子；否则右孩子是结点 2*i+1 。

## 3 二叉树存储方式

### 3.1 顺序存储结构

只有完全二叉树（满二叉树是完全二叉树的一种特殊情况）可以用顺序存储，普通二叉树需要转为完全二叉树，如下图

![img](https://tva1.sinaimg.cn/large/006tNbRwly1ga2zfmnqz6j308g04c74a.jpg)

![img](https://tva1.sinaimg.cn/large/006tNbRwly1ga2zgct3h7j306w01ijr7.jpg)

完全二叉树的顺序存储，仅需从根节点开始，按照层次依次将树中节点存储到数组即可

### 3.2 链式存储结构

![普通二叉树示意图](http://data.biancheng.net/uploads/allimg/181228/2-1Q22R02H9133.gif)

存储结构示意图如下

![二叉树链式存储结构示意图](http://data.biancheng.net/uploads/allimg/181228/2-1Q22R035341H.gif)

其节点结构由 3 部分构成：

- 指向左孩子节点的指针（Lchild）；
- 节点存储的数据（data）；
- 指向右孩子节点的指针（Rchild）；

![二叉树节点结构](http://data.biancheng.net/uploads/allimg/181228/2-1Q22R02Q6392.gif)

## 4 二叉树四种遍历方式

**深度优先一般用递归，广度优先一般用队列。一般情况下能用递归实现的算法大部分也能用堆栈来实现**

```python
class Node():
    # 节点类
    def __init__(self, data=-1):
        self.data = data
        self.left = None
        self.right = None
```

### 4.1 先序遍历

实现思想：

1. 访问根节点；
2. 访问当前节点的左子[树](http://data.biancheng.net/view/23.html)；
3. 若当前节点无左子树，则访问当前节点的右子树；

![img](http://data.biancheng.net/uploads/allimg/170830/2-1FS01325394F.png)

```
1 2 4 5 3 6 7
```

递归实现：

```python
def preorder(self, root):
      """递归实现先序遍历"""
      if root == None:
          return
      print root.elem
      self.preorder(root.lchild)
      self.preorder(root.rchild)
```

非递归实现：

### 4.2 中序遍历

实现思想：

1. 访问当前节点的左子[树](http://data.biancheng.net/view/23.html)；
2. 访问根节点；
3. 访问当前节点的右子树；

递归实现：

```python
def inorder(self, root):
      """递归实现中序遍历"""
      if root == None:
          return
      self.inorder(root.lchild)
      print root.elem
      self.inorder(root.rchild)
```

非递归实现：





### 4.3 后序遍历

实现思想：

从根节点出发，依次遍历各节点的左右子[树](http://data.biancheng.net/view/23.html)，直到当前节点左右子树遍历完成后，才访问该节点元素。

递归实现：

```python
def postorder(self, root):
      """递归实现后续遍历"""
      if root == None:
          return
      self.postorder(root.lchild)
      self.postorder(root.rchild)
      print root.elem
```



### 4.4 层次遍历

广度优先遍历：

```python
def breadth_travel(self, root):
        """利用队列实现树的层次遍历"""
        if root == None:
            return
        queue = []
        queue.append(root)
        while queue:
            node = queue.pop(0)
            print node.elem,
            if node.lchild != None:
                queue.append(node.lchild)
            if node.rchild != None:
                queue.append(node.rchild)
```

