# 21-面向对象(系统内置方法)

## 1 信息格式化操作

### 1.1 <font color=red>`__str__`</font>

```python
作用
    一个对象的描述字符串, 更加方便用户阅读, 对用户更友好(属性值之类的)
触发方式
    print 打印一个对象时
    str() 函数时
格式
    def __str__(self):
          return "描述信息"
```

```python
class Person:
    def __init__(self, n, a):
        self.name = n
        self.age = a

    def __str__(self):
        return "这个人的姓名是%s, 这个人的年龄是:%s" % (self.name, self.age)

p1 = Person("fkm", 18)
# print(p1.name)
# print(p1.age)
print(p1) 

# 不适用 __str__ 时，打印结果是：<__main__.Person object at 0x10a9e4630>
# 使用后，打印结果：这个人的姓名是fkm, 这个人的年龄是:18

#触发方式二
s = str(p1)
print(s, type(s)) # 这个人的姓名是fkm, 这个人的年龄是:18 <class 'str'>
```

### 1.2 <font color=red>`__repr__`</font>

```python
作用
    一个对象的描述字符串, 更加方便机器处理, 对机器更友好(开发人员查看，实际类型和地址等)
触发方式
    当我们在交互模式下, 直接执行某个变量, 就会输出对应信息
    repr() 函数时
格式
    def __repr__(self):
    return "描述信息"
注意
    一般情况下, 应满足如下等式
        obj == eval(repr(obj))
    或者描述一个实例详细的信息(类名等等)
```

- 通常通过以下方式

  ```python
  print(repr(p1)) # <__main__.Person object at 0x10a9e4630>
  ```

- 重写repr 描述

  ```python
  class Person:
      def __init__(self, n, a):
          self.name = n
          self.age = a
  
      def __repr__(self):
          return "reprxxxxx"
  
  p1 = Person("fkm", 18)
  print(p1) # reprxxxxx
  
  s = str(p1)
  print(s, type(s)) # reprxxxxx <class 'str'>
  
  print(repr(p1)) # reprxxxxx
  ```

- 如果同时重写**str** 和 **repr**

  <font color=red>会优先寻找__str__，如果没有重写，则找__repr__</font>，都没有就按照系统默认的

  ```python
  class Person:
      def __init__(self, n, a):
          self.name = n
          self.age = a
  
      def __str__(self):
          return "这个人的姓名是%s, 这个人的年龄是:%s" % (self.name, self.age)
  
      def __repr__(self):
          return "reprxxxxx"
  
  p1 = Person("fkm", 18)
  print(p1) # 这个人的姓名是fkm, 这个人的年龄是:18
  
  s = str(p1)
  print(s, type(s)) # 这个人的姓名是fkm, 这个人的年龄是:18 <class 'str'>
  
  print(repr(p1)) # reprxxxxx
  ```

### 1.3  __str__ 和 __repr__使用区别

```python
import datetime

t = datetime.datetime.now()
print(t) # 面向用户
print(repr(t)) # 面向开发者

tmp = repr(t)
result = eval(tmp) # 通过 eval 将__repr__面向开发者的对象,转为面向用户
print(result)

>>> 打印结果
2018-05-21 20:57:55.731912
datetime.datetime(2018, 5, 21, 20, 57, 55, 731912)
2018-05-21 20:57:55.731912
```

------

## 2 调用操作

### 2.1 <font color=red>`__call__`</font>

```python
作用
    使得“对象”具备当做函数，来调用的能力
使用
    1. 实现实例方法 __call__
    2. 那么创建好的实例, 就可以通过函数的形式来调用
        实例(参数)
应用场景
    有点类似于之前所讲的"偏函数"的应用场景
    可以将"常变参数"和"不常变参数"进行分离
案例
    不同类型的笔, 画不同的图形
```

- 简单 call 方法是使用

  ```python
  class Person:
      def __call__(self, *args, **kwargs):
          print("xxx", args, kwargs)
          pass
  
  p = Person()
  p(123, 456, name="fkm") 
  
  >>> 打印结果
   xxx (123, 456) {'name': 'fkm'}
  ```

- 回顾偏函数的使用

  ```python
  #题目：创建很多个画笔, 画笔的类型(钢笔, 铅笔), 画笔的颜色(红, 黄色, 青色, 绿色)
  
  print("创建了一个%s这个类型的画笔, 它是%s颜色" % ("钢笔", "红色"))
  print("创建了一个%s这个类型的画笔, 它是%s颜色" % ("钢笔", "黄色"))
  print("创建了一个%s这个类型的画笔, 它是%s颜色" % ("钢笔", "青色"))
  
  print("-" * 10 + "以上是 普通 写法" + "-" * 10)
  
  def createPen(p_color, p_type):
      print("创建了一个%s这个类型的画笔, 它是%s颜色" % (p_type, p_color))
  
  
  createPen("钢笔", "红色")
  createPen("钢笔", "绿色")
  createPen("钢笔", "黄色")
  
  print("-" * 10 + "以上是 函数式 写法" + "-" * 10)
  
  
  import functools
  
  gangbiFunc = functools.partial(createPen, p_type="钢笔")
  
  gangbiFunc("红色")
  gangbiFunc("黄色")
  gangbiFunc("绿色")
  
  print("-" * 10 + "以上是 偏函数 写法" + "-" * 10)
  ```

- 参考偏函数，使用__call__ 方法

  ```python
  class PenFactory:
  
      def __init__(self, p_type):
          self.p_type = p_type
  
      def __call__(self, p_color):
          print("创建了一个%s这个类型的画笔, 它是%s颜色" % (self.p_type, p_color))
  
  gangbiF = PenFactory("钢笔")
  gangbiF("红色")
  gangbiF("绿色")
  gangbiF("黄色")
  
  print(" - " * 20)
  
  qianbiF = PenFactory("铅笔")
  qianbiF("红色") # 实例调用 call 方法
  qianbiF("绿色")
  qianbiF("黄色")
  
  >>>打印结果
  创建了一个钢笔这个类型的画笔, 它是红色颜色
  创建了一个钢笔这个类型的画笔, 它是绿色颜色
  创建了一个钢笔这个类型的画笔, 它是黄色颜色
   -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  -  - 
  创建了一个铅笔这个类型的画笔, 它是红色颜色
  创建了一个铅笔这个类型的画笔, 它是绿色颜色
  创建了一个铅笔这个类型的画笔, 它是黄色颜色
  ```

------

## 3 索引操作

```python
作用
    可以对一个实例对象进行索引操作

步骤
    1. 实现三个内置方法
        设置元素的方法
            def __setitem__(self, key, value):
        获取元素的方法
            def __getitem__(self, item):
        删除元素的方法
            def __delitem__(self, key):

    2. 可以以索引的形式操作对象
        增/改
            p[1] = 666
            p["name"] = "sz"
        查
            p["name"]
            p[1]
        删
            del p["name"]
            del p[1]
```

```python
class Person:
    def __init__(self):
        self.cache = {}

    def __setitem__(self, key, value):
        # print("setitem", key, value)
        self.cache[key] = value

    def __getitem__(self, item):
        # print("getitem", item)
        return self.cache[item]

    def __delitem__(self, key):
        # print("delitem", key)
        del self.cache[key]

p = Person()
p["name"] = "fkm"

print(p["name"])

del p["name"]

# print(p["name"]) # error 实际报错是 __getitem__实例方法内的 cache 字典获取操作
print(p.cache)
```

------

## 4 切片操作

```python
作用
    可以对一个实例对象进行切片操作
步骤
    Python2.x
        1. 实现三个内置方法
            __setspice__
                设置某个元素切片时调用
            __getspice__
                获取某个元素切片时调用
            __delspice__
                删除某个元素切片时调用
        2. 可以直接按照切片的方式操作对象
            p[1, 6, 2]
        注意: 过期

    Python3.x
        统一由"索引操作"进行管理
            def __setitem__(self, key, value):
            def __getitem__(self, item):
            def __delitem__(self, key):
```

* 通过切片进行赋值、获取、删除操作时

  ```python
  class Person:
  
      def __setitem__(self, key, value):
          print(key, value)
  
      def __getitem__(self, item):
          print(item)
  
      def __delitem__(self, key):
          print(key)
  
  
  p = Person()
  # 赋值操作
  p[1:4:2] = ["a", "b"]
  
  #获取操作
  p[1:4:2]
  
  #删除操作
  del p[1:4:2]
  
  >>> 打印结果
  
  slice(1, 4, 2) ['a', 'b']
  slice(1, 4, 2)
  slice(1, 4, 2)
  ```

